---
layout:default
title:抓取flash数据
author:穆亚磊
date:2018-10-22
tags:
   - 爬虫
   - flash 
   - AMF 
---

###                                             如何抓取基于Flex技术的网站
>Adobe Flex是基于Flash平台，涵盖了支持RIA（Rich Internet Applications）的开发和部署的一系列技术组合。有很多基于Web的网络游戏都是采用Flex技术开发的。
>Flash（客户端）与服务器之间通信既支持HTTP协议（具体的正文消息格式可以是text、XML、JSON、AMF等）也支持原始的Sockets，以HTTP协议较为常见。
>对于使用text，XML或JSON形式消息格式的Flex应用来说，对其的分析和抓取方法与基于Ajax的网站一样：
>通过HTTP协议抓包工具（例如，Fiddler，Firebug）分析请求的结构（请求方法、URL、相关参数）和步骤，然后用程序模拟发出同样格式的请求，再对返回的数据进行解析和提取。

>本文主要介绍使用AMF消息格式的Flex应用的抓取方法。以“中国农产品批发市场信息公示系统”（下简称“农产品系统”）为例，其URL是http://jgsb.agri.gov.cn/flexapps/hqApp.swf，我们的目标是抓取这个系统中实时公布的最新农产品价格信息。
>AMF(Action Message Format，https://en.wikipedia.org/wiki/Action_Message_Format)是Flash与服务端通信的一种常见的二进制编码模式，其传输效率高，可以在HTTP层面上传输。现在很多Flash WebGame都采用这样的消息格式。

>我们可以直接使用Fidder抓到AMF包，但是看到的POST DATA正文是乱码形式的，这是因为AMF使用了特殊的封装和编码方式，只有经过正确的AMF解码和解析之后才能查看到“明文”形式。目前支持AMF解析的抓包工具是charles（和Fiddler一样，它也是一款基于HTTP PROXY原理的HTTP协议抓包工具），它原生支持解析AMF消息，无需安装任何额外插件或补丁。

分析步骤如下：
1.启动charles。
2.在浏览器中访问“农产品系统”，点击下一页。
3.我们在charles中就可以看到对应的数据包，切换到AMF标签下，可以看到请求/应答的AMF数据被解析成明文形式了（类似JSON格式的展现形式）。对AMF格式的请求和响应的数据进行分析，了解其结构和各参数的含义，为后面我们用程序进行实现做准备。

如下图所示，这是HTTP请求的POST DATA。

![2018-10-22-抓取flash数据_图片1.jpg](https://github.com/muyalei/muyalei.github.io/blob/gh-pages/img/2018-10-22-%E6%8A%93%E5%8F%96flash%E6%95%B0%E6%8D%AE_%E5%9B%BE%E7%89%871.jpg)

>我们需要分析发出请求里的参数含义，以及消息的组成结构。其正文部分是一个RemotingMessage类型的消息，该消息的正文又有三个参数：
1. 第一个参数是一个com.itown.kas.pfsc.report.po.HqPara对象，它有4个属性（marketInfo、breedInfoDl、breedInfo、province），值都是Null，对应网页（Flash）上的四个查询选项（省份、市场、品类大全、品种名称）。
2.第二个参数控制当前的页码。
3.第三个参数控制每页显示的条数，默认是15。后面采集代码里我们会使用50。

略过对其它非关键参数以及应答数据的分析过程。

PyAMF 是一个Python 实现的AMF协议的编码和解码器。很遗憾的是目前这个项目的官网已经无法访问了，无法查看上面的文档和示例程序，这大大增加了开发难度。好在通过谷歌（对，不是百度）还能找到一些参考资料和别人项目中使用的例子。

下面直接上源码：
```
# coding: utf-8
# agri.gov.cn_amf_client.py
# http://jgsb.agri.gov.cn/flexapps/hqApp.swf数据抓取
import urllib2
import uuid
import pyamf
from pyamf import remoting
from pyamf.flex import messaging
class HqPara:
    """查询参数
    """
    def __init__(self):
        self.marketInfo = None
        self.breedInfoDl = None
        self.breedInfo = None
        self.provice = None
# https://en.wikipedia.org/wiki/Action_Message_Format
# registerClassAlias("personTypeAlias", Person);
# 注册自定义的Body参数类型，这样数据类型com.itown.kas.pfsc.report.po.HqPara就会在后面被一并发给服务端（否则服务端就可能返回参数不是预期的异常Client.Message.Deserialize.InvalidType）
pyamf.register_class(HqPara, alias='com.itown.kas.pfsc.report.po.HqPara')
# 构造flex.messaging.messages.RemotingMessage消息
msg = messaging.RemotingMessage(messageId=str(uuid.uuid1()).upper(),
                                clientId=str(uuid.uuid1()).upper(),
                                operation='getHqSearchData',
                                destination='reportStatService',
                                timeToLive=0,
                                timestamp=0)
# 第一个是查询参数，第二个是页数，第三个是控制每页显示的数量（默认每页只显示15条）
msg.body = [HqPara(), '1', '50']
msg.headers['DSEndpoint'] = None
msg.headers['DSId'] = str(uuid.uuid1()).upper()
# 按AMF协议编码数据
req = remoting.Request('null', body=(msg,))
env = remoting.Envelope(amfVersion=pyamf.AMF3)
env.bodies = [('/1', req)]
data = bytes(remoting.encode(env).read())
# 提交请求
url = 'http://jgsb.agri.gov.cn/messagebroker/amf'
req = urllib2.Request(url, data, headers={'Content-Type': 'application/x-amf'})
# 解析返回数据
opener = urllib2.build_opener()
# 解码AMF协议返回的数据
resp = remoting.decode(opener.open(req).read())
for i, record in enumerate(resp.bodies[0][1].body.body[0]):
    print i, record['farmProduceName'], \
          record['marketName'], \
          record['maxPrice'], \
          record['minPrice'], \
          record['averagePrice'], \
          record['producAdd'] and record['producAdd'], \
          record['reportMan']<br>
```

运行结果截图：

![2018-10-22-抓取flash数据_图片2.jpg](https://github.com/muyalei/muyalei.github.io/blob/gh-pages/img/2018-10-22-%E6%8A%93%E5%8F%96flash%E6%95%B0%E6%8D%AE_%E5%9B%BE%E7%89%872.jpg)

---
***

个人整理：
1.amf协议处理后的数据通过http协议与服务器端通信，可以理解为先用amf协议加密数据后再用http协议传输。
2.目前的农产品批发市场网站已经有所改变，breedInfo、breedInfoDI这两个参数更改成了一个amf协议的对象，处理方式一样，仿照注册HqPara的方式构造这两个对象、并注册，最后在构造HqPara对象时，将这两个类实例化即可，如下例所示：
```
class HqPara(object):
    def __init__(self):
        self.provice = None
        self.breedInfo = breedInfo()
        self.marketInfo = None
        self.breedInfoDI = breedInfoDI()
#注册自定义的Body参数类型，这样数据类型com.itown.kas.pfsc.report.po.HqPara就会在后面被一并发
#给服务端（否则服务端就可能返回参数不是预期的异常Client.Message.Deserialize.InvalidType），breedInfoDI/breedInfo对象同理
pyamf.register_class(HqPara,alias='com.itown.kas.pfsc.report.po.HqPara')
```



