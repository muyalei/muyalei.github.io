---
layout: default
author: muyalei
date: 2018-12-03
title: redis安装、配置
tags:
   - redis
---


***转载自[http://www.cnblogs.com/xuchunlin/p/6676308.html](http://www.cnblogs.com/xuchunlin/p/6676308.html)***


Redis 的官方下载站是http://redis.io/download

怎么安装 Redis 数据库呢？下面将介绍Linux 版本的安装方法

步骤一: 下载Redis
下载安装包：wget http://redis.googlecode.com/files/redis-2.2.12.tar.gz
```
[root@localhost 4setup]# wget http://redis.googlecode.com/files/redis-2.2.12.tar.gz
--19:06:56-- http://redis.googlecode.com/files/redis-2.2.12.tar.gz
正在解析主机 redis.googlecode.com... 74.125.71.82
Connecting to redis.googlecode.com|74.125.71.82|:80... 已连接。
已发出 HTTP 请求，正在等待回应... 200 OK
长度：455240 (445K) [application/x-gzip]
Saving to: `redis-2.2.12.tar.gz'
100%[==========================================>] 455,240 34.8K/s in 13s
19:07:16 (34.8 KB/s) - `redis-2.2.12.tar.gz' saved [455240/455240]
[root@localhost 4setup]#
```
步骤二: 编译源程序
```
[root@localhost 4setup]# ll
总计 29168
-rw-r--r-- 1 root root 455240 2011-07-22 redis-2.2.12.tar.gz
[root@localhost 4setup]# tar xzf redis-2.2.12.tar.gz
[root@localhost 4setup]# cd redis-2.2.12
[root@localhost redis-2.2.12]# make
cd src && make all
make[1]: Entering directory `/root/4setup/redis-2.2.12/src'
```
步骤三: 启动Redis 服务
```
[root@localhost redis-2.2.12]# src/redis-server
[6246] 05 Aug 19:17:22 # Warning: no config file specified, using the default config. In order to
specify a config file use 'redis-server /path/to/redis.conf'
[6246] 05 Aug 19:17:22 * Server started, Redis version 2.2.12
[6246] 05 Aug 19:17:22 # WARNING overcommit_memory is set to 0! Background save may fail
under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to
/etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this
to take effect.
[6246] 05 Aug 19:17:22 * The server is now ready to accept connections on port 6379
[6246] 05 Aug 19:17:22 - 0 clients connected (0 slaves), 539544 bytes in use
```
Redis 服务端的默认连接端口是 6379

步骤四: 将Redis 作为 Linux 服务随机启动
vi /etc/rc.local, 使用vi 编辑器打开随机启动配置文件，并在其中加入下面一行代码
/root/4setup/redis-2.2.12/src/redis-server

步骤五: 客户端连接验证
新打开一个Session 输入：src/redis-cli，如果出现下面提示，那么您就可以开始Redis 之旅了
```
[root@localhost redis-2.2.12]# src/redis-cli
redis 127.0.0.1:6379>
```
步骤六: 查看Redis 日志
查看服务器端session，即可对Redis 的运行状况进行查看或分析了
```
[6246] 05 Aug 19:24:33 - 0 clients connected (0 slaves), 539544 bytes in use
[6246] 05 Aug 19:24:37 - Accepted 127.0.0.1:51381
[6246] 05 Aug 19:24:38 - 1 clients connected (0 slaves), 547372 bytes in use
```
　　　　以上的几个步骤就OK 了！！这样一个简单的Redis 数据库就可以畅通无阻地运行起来了。

步骤七: 停止Redis 实例
最简单的方法是在启动实例的session 中，直接使用Control-C 来将实例停止。
我们还可以用客户端来停止服务，如可以用shutdown 来停止Redis 实例, 具体如下:
```
[root@localhost redis-2.2.12]# src/redis-cli shutdown
```
步骤八：
如果是一个专业的DBA，那么实例启动时会加很多的参数以便使系统运行的非常稳定，这样就可能会在启动时在Redis 后面加一个参数，以指定配置文件的路径，就象mysql 一样的读取启动配置文件的方式来启动数据库。源码编译完成后，在redis-2.2.12 目录下有一个redis.conf 文件，这个文件即是Redis 的配置文件，用配置文件来启动Redis 的方法如下:
```
[root@localhost redis-2.2.12]# src/redis-server redis.conf
[6353] 05 Aug 19:36:45 * Server started, Redis version 2.2.12
[6353] 05 Aug 19:36:45 # WARNING overcommit_memory is set to 0! Background save may fail
under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to
/etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this
to take effect.
[6353] 05 Aug 19:36:45 * The server is now ready to accept connections on port 6379
[6353] 05 Aug 19:36:45 - 0 clients connected (0 slaves), 539540 bytes in use
```
Redis 支持很多的参数，但都有默认值。

<>daemonize:

默认情况下，redis 不是在后台运行的，如果需要在后台运行，把该项的值更改为yes

<>pidfile

当Redis 在后台运行的时候，Redis 默认会把pid 文件放在/var/run/redis.pid，你可以配置到其他地址。当运行多个redis 服务时，需要指定不同的pid 文件和端口

<>bind

指定Redis 只接收来自于该IP 地址的请求，如果不进行设置，那么将处理所有请求，在生产环境中最好设置该项

<>port

监听端口，默认为6379

<>timeout

设置客户端连接时的超时时间，单位为秒。当客户端在这段时间内没有发出任何指令，那么关闭该连接

<>loglevel

log 等级分为4 级，debug, verbose, notice, 和warning。生产环境下一般开启notice

<>logfile

配置log 文件地址，默认使用标准输出，即打印在命令行终端的窗口上

<>databases

设置数据库的个数，可以使用SELECT <dbid>命令来切换数据库。默认使用的数据库是0

<>save

设置Redis 进行数据库镜像的频率。

if(在60 秒之内有10000 个keys 发生变化时){进行镜像备份

}else if(在300 秒之内有10 个keys 发生了变化){进行镜像备份

}else if(在900 秒之内有1 个keys 发生了变化){进行镜像备份

}

<>rdbcompression

在进行镜像备份时，是否进行压缩

<>dbfilename

镜像备份文件的文件名

<>dir

数据库镜像备份的文件放置的路径。这里的路径跟文件名要分开配置是因为Redis 在进行备份时，先会将当前数据库的状态写入到一个临时文件中，等备份完成时，再把该该临时文件替换为上面所指定的文件，而这里的临时文件和上面所配置的备份文件都会放

在这个指定的路径当中

<>slaveof

设置该数据库为其他数据库的从数据库

<>masterauth

当主数据库连接需要密码验证时，在这里指定

<>requirepass

设置客户端连接后进行任何其他指定前需要使用的密码。警告：因为redis 速度相当快，所以在一台比较好的服务器下，一个外部的用户可以在一秒钟进行150K 次的密码尝试，这意味着你需要指定非常非常强大的密码来防止暴力破解。

<>maxclients

限制同时连接的客户数量。当连接数超过这个值时，redis 将不再接收其他连接请求，客户端尝试连接时将收到error 信息。

<>maxmemory

设置redis 能够使用的最大内存。当内存满了的时候，如果还接收到set 命令，redis 将先尝试剔除设置过expire 信息的key，而不管该key 的过期时间还没有到达。在删除时，将按照过期时间进行删除，最早将要被过期的key 将最先被删除。如果带有expire 信息的key 都删光了，那么将返回错误。这样，redis 将不再接收写请求，只接收get 请求。

maxmemory 的设置比较适合于把redis 当作于类似memcached 的缓存来使用。

<>appendonly

默认情况下，redis 会在后台异步的把数据库镜像备份到磁盘，但是该备份是非常耗时的，而且备份也不能很频繁，如果发生诸如拉闸限电、拔插头等状况，那么将造成比较大范围的数据丢失。所以redis 提供了另外一种更加高效的数据库备份及灾难恢复方式。开启append only 模式之后，redis 会把所接收到的每一次写操作请求都追加到appendonly.aof 文件中，当redis 重新启动时，会从该文件恢复出之前的状态。但是这样会造成appendonly.aof 文件过大，所以redis 还支持了BGREWRITEAOF 指令，对appendonly.aof 进行重新整理。所以我认为推荐生产环境下的做法为关闭镜像，开启appendonly.aof，同时可以选择在访问较少的时间每天对appendonly.aof 进行重写一次。

<>appendfsync

设置对appendonly.aof 文件进行同步的频率。always 表示每次有写操作都进行同步，everysec 表示对写操作进行累积，每秒同步一次。这个需要根据实际业务场景进行配置

<>vm-enabled

是否开启虚拟内存支持。因为redis 是一个内存数据库，而且当内存满的时候，无法接收新的写请求，所以在redis 2.0 中，提供了虚拟内存的支持。但是需要注意的是，redis中，所有的key 都会放在内存中，在内存不够时，只会把value 值放入交换区。这样保证了虽然使用虚拟内存，但性能基本不受影响，同时，你需要注意的是你要把vm-max-memory 设置到足够来放下你的所有的key

<>vm-swap-file

设置虚拟内存的交换文件路径

<>vm-max-memory

这里设置开启虚拟内存之后，redis 将使用的最大物理内存的大小。默认为0，redis 将把他所有的能放到交换文件的都放到交换文件中，以尽量少的使用物理内存。在生产环境下，需要根据实际情况设置该值，最好不要使用默认的0

<>vm-page-size

设置虚拟内存的页大小，如果你的value 值比较大，比如说你要在value 中放置博客、新闻之类的所有文章内容，就设大一点，如果要放置的都是很小的内容，那就设小一点。

<>vm-pages

设置交换文件的总的page 数量，需要注意的是，page table 信息会放在物理内存中，每8 个page 就会占据RAM 中的1 个byte。总的虚拟内存大小 ＝ vm-page-size * vm-pages

<>vm-max-threads

设置VM IO 同时使用的线程数量。因为在进行内存交换时，对数据有编码和解码的过程，所以尽管IO 设备在硬件上本上不能支持很多的并发读写，但是还是如果你所保存的vlaue 值比较大，将该值设大一些，还是能够提升性能的

<>glueoutputbuf

把小的输出缓存放在一起，以便能够在一个TCP packet 中为客户端发送多个响应，具体原理和真实效果我不是很清楚。所以根据注释，你不是很确定的时候就设置成yes

<>hash-max-zipmap-entries

在redis 2.0 中引入了hash 数据结构。当hash 中包含超过指定元素个数并且最大的元素没有超过临界时，hash 将以一种特殊的编码方式（大大减少内存使用）来存储，这里可以设置这两个临界值

<>activerehashing

开启之后，redis 将在每100 毫秒时使用1 毫秒的CPU 时间来对redis 的hash 表进行重新hash，可以降低内存的使用。当你的使用场景中，有非常严格的实时性需要，不能够接受Redis 时不时的对请求有2 毫秒的延迟的话，把这项配置为no。如果没有这么严格的实时性要求，可以设置为yes，以便能够尽可能快的释放内存
