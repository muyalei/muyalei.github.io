---
layout: default
author: muyalei
date: 2018-11-13
title: Django数据库查询—如何获取指定范围的数据
tags:
   - Django
---

***转载自[http://www.cnblogs.com/lhj588/archive/2012/02/17/2356478.html](http://www.cnblogs.com/lhj588/archive/2012/02/17/2356478.html)***

```
__exact 精确等于 like ‘aaa’
__iexact 精确等于 忽略大小写 ilike ‘aaa’
__contains 包含 like ‘%aaa%’
__icontains 包含 忽略大小写 ilike ‘%aaa%’，但是对于sqlite来说，contains的作用效果等同于icontains。
__gt 大于
__gte 大于等于
__lt 小于
__lte 小于等于
__in 存在于一个list范围内
__startswith 以…开头
__istartswith 以…开头 忽略大小写
__endswith 以…结尾
__iendswith 以…结尾，忽略大小写
__range 在…范围内
__year 日期字段的年份
__month 日期字段的月份
__day 日期字段的日
__isnull=True/False
__isnull=True 与 __exact=None的区别
```
```
class Blog(models.Model):
name = models.CharField(max_length=100)
tagline = models.TextField()
```
def __unicode__(self):
return self.name
```
```
class Author(models.Model):
name = models.CharField(max_length=50)
email = models.EmailField()
```
```
def __unicode__(self):
return self.name
```
```
class Entry(models.Model):
blog = models.ForeignKey(Blog)
headline = models.CharField(max_length=255)
body_text = models.TextField()
pub_date = models.DateTimeField()
authors = models.ManyToManyField(Author)
```
```
def __unicode__(self):
return self.headline
```

这是model，有blog，author，以及entry；其中entry分别与blog与author表关 联，entry与blog表是通过 外键(models.ForeignKey())相连，属于一对多的关系，即一个entry对应多个blog，entry与author是多对多的关系， 通过modles.ManyToManyField()实现。

一、插入数据库，用save()方法实现，如下：
```
>>> from mysite.blog.models import Blog
>>> b = Blog(name=’Beatles Blog’, tagline=’All the latest Beatles news.’)
>>> b.save()
```

二、更新数据库，也用save()方法实现，如下：
```
>> b5.name = ‘New name’
>> b5.save()
```

保存外键和多对多关系的字段，如下例子：

更新外键字段和普通的字段一样，只要指定一个对象的正确类型。
```
>>> cheese_blog = Blog.objects.get(name=”Cheddar Talk”)
>>> entry.blog = cheese_blog
>>> entry.save()
```

更新多对多字段时又一点不太一样，使用add()方法添加相关联的字段的值。
```
>> joe = Author.objects.create(name=”Joe”)
>> entry.authors.add(joe)
```
三、检索对象
```
>>> Blog.objects

>>> b = Blog(name=’Foo’, tagline=’Bar’)
>>> b.objects
Traceback:
…
AttributeError: “Manager isn’t accessible via Blog instances.”
```

1、检索所有的对象

`>>> all_entries = Entry.objects.all()`

使用all()方法返回数据库中的所有对象。

2、检索特定的对象

使用以下两个方法：

fileter(**kwargs)

返回一个与参数匹配的QuerySet,相当于等于(=).

exclude(**kwargs)

返回一个与参数不匹配的QuerySet,相当于不等于(!=)。


Entry.objects.filter(pub_date__year=2006)

不使用Entry.objects.all().filter(pub_date__year=2006),虽然也能运行，all()最好再获取所有的对象时使用。

上面的例子等同于的sql语句：

slect * from entry where pub_date_year=’2006′




